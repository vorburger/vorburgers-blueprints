package ch.vorburger.mtemplating;

import java.io.IOException;
import java.io.Reader;
import java.io.Writer;
import java.nio.CharBuffer;

/**
 * Generator for Template Generators.
 *
 * @author Michael Vorburger
 */
// TODO self-bootstrap me, and generate this via a previous version of this generator!
public class GeneratorGenerator implements Generator<Template> {

	static public void generateIt(Writer w, Template t) throws IOException {
		w.write("package ");
		w.write(t.dottedPackageName);
		w.write(";\n\n");
		
//		for (Class<?> typeToImport : t.typesToImport) {
//			w.write("import ");
//			w.write(typeToImport.getCanonicalName());
//			w.write(";\n");
//		}
		
		// TODO Insert some kind of @Generated by @see template  
		w.write("public class ");
		w.write(t.className);
		w.write(" {\n\n");
		
		w.write("\tstatic public void generate(java.io.Writer w, ");
		w.write(t.parameterClass.getCanonicalName());
		w.write(' ');
		w.write(t.parameterVariableName);
		w.write(") throws IOException {\n");
		
		while(hasMore(t.reader)) {
			if(check(t.reader, t.expressionEscapeStartTag)) {
				
			} else if (check(t.reader, t.expressionEscapeEndTag)) {
			} else if (check(t.reader, t.codeEscapeStartTag)) {
				// NOTE: MUST check the 'longer' escape tag before the shorter one!
				
				// TODO Should check that there are no embedded escapes
			} else if (check(t.reader, t.codeEscapeEndTag)) {
			} else {
				// OK so it's just plain text to pass through
			}
			
		}
		
		int i;
		while ((i = t.reader.read()) != -1) {
			char c = (char) i;
			
			w.write("\tw.write(\"");
			w.write(c);
			w.write("\");\n");
		}
		
		w.write("\t}\n\n");
	}

	/**
	 * Check if the Reader has more to read, without consuming it.
	 */
	// TODO move this out into a ReaderUtil ? Or, better, create a BetterReader wrapper?
	// TODO Am I dumb or is this the best & only way of doing this?!
	static boolean hasMore(Reader reader) throws IOException {
		reader.mark(1);
		int next = reader.read();
		reader.reset();
		return !(next == -1);
	}
	
	/**
	 * Check if what's coming up to read next in a Reader matches some kind of 'tag'.
	 * If it doesn't match, then the Reader is reset() and nothing is read.
	 * If it matches, that tag is consumed (read).
	 */
	// TODO move this out into a ReaderUtil ? Or, better, create a BetterReader wrapper?
	static boolean check(Reader reader, CharSequence tag) throws IOException {
		reader.mark(tag.length());
		char[] buffer = new char[tag.length()];
		int n = reader.read(buffer);
		
		if (n == tag.length() && equals(tag, buffer)) {
			return true;
		} else {
			reader.reset();
			return false;
		}
	}

	/**
	 * Highly efficient comparison of CharSequence and char[].
	 * Avoids the creation of an intermediary object.
	 */
	// TODO move this out into a ReaderUtil ? Or, better, create a BetterReader wrapper?
	// TODO You'd think something like this is available in the JDK (or Apache Commons), but I couldn't find one.
	static boolean equals(CharSequence charSequence, char[] charArray) {
		// Following code is inspired by java.util.Arrays.equals()
		if (charSequence == null && charArray == null) {
			return true;
		}
		if (charSequence == null || charArray == null) {
			return false;
		}
		int length = charArray.length;
		if (charSequence.length() != length) {
			return false;
		}
		for (int i=0; i<length; i++) {
            if (charSequence.charAt(i) != charArray[i]) {
                return false;
            }
		}
		return true;
	}

	@Override
	public void generate(Writer w, Template i) throws IOException {
		generateIt(w, i);
	}
}
